diffPowerPrimaryMonomial = method()

diffPowerPrimaryMonomial( MonomialIdeal, ZZ) := MonomialIdeal => (I, n) ->
(
    -- throw an exception if I is not a primary ideal
    assert isPrimary I;

    -- assuming generated by pure powers (from irreducibleDecomposition)
    -- getting the values of the powers
    -- and the variables appearing in I
    G = first entries mingens I;
    num = #G;
    -- an element of L is (variable, power of variable in generators of I)
    L = apply(num, i -> ((support G_i)_0, first degree G_i));
    -- finding generators of diff power
    Gpow = apply(num, i -> ((L_i)_0)^((L_i)_1 + n - 1));
    -- get a list of combinations of variables
    C = {};
    for i from 2 to num do 
        C = append(C, select(compositions (num, i), comp -> all(comp, c -> c <= 1)));
    -- for each combination, assign powers
    for i from 0 to #C - 1 do
        (for j in C_i do
            (Gvars = {};
            deg = n;
            for k from 0 to num - 1 do
                (if ((j)_k) > 0 
                then
                    (deg = deg + ((L_k)_1) - 1; 
                    Gvars = append(Gvars, (L_k)_0));
                );
            Pows = select(compositions(#Gvars, deg), comp -> all(comp, c -> c > 0));
            for p in Pows do 
                (temp = 1;
                apply(i + 2, l -> (temp = temp * ((Gvars_l)^(p_l))));
                Gpow = append(Gpow, temp);
                )
            )
        );
    monomialIdeal(Gpow)
)


diffPowerMonomial = method()

diffPowerMonomial( MonomialIdeal, ZZ) := MonomialIdeal => (I, n) ->
(
    -- take a primary decomposition of I,
    -- take each primary component to nth differential power,
    -- intersect the ideals you get.

    intersect apply(irreducibleDecomposition I, J -> diffPowerPrimaryMonomial(J, n))
)

multipleContainmentMonomial = method()

multipleContainmentMonomial( MonomialIdeal, ZZ) := ZZ => (I, n) ->
(
    d = 1;
    -- TODO insert upper bound to stop infinite loop?
    while (not(isSubset(diffPowerMonomial(I, d*n), I^n))) do (d = d + 1);
    d
)

-- Brenner, Jeffries, Nùñez-Betancourt method

diffPowerPoly = method()

diffPowerPoly( Ideal, ZZ) := Ideal => ( I, n) ->
(   S = ring(I);

    -- get new ring with additional variables
    K = coefficientRing S;
    G = gens S;
    num = #G;
    G' = for g in G list concatenate(toString(g), "1");
    T = K[G', G,  MonomialOrder => Eliminate num];
    V = gens T;
    Dgen = for i from 0 to num - 1 list (V_(i + num) - V_i);
    D = ideal(Dgen);
    J = sub(I, for i from 0 to num - 1 list (G_i => V_i));

    -- perform calculation
    result = selectInSubring(1, gens gb (J + D^n));
    -- need to put the output in the correct underlying ring
    substitute(ideal(result), S)
)