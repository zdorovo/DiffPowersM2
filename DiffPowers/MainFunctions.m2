diffPowerPrimaryMonomial = method()

diffPowerPrimaryMonomial( MonomialIdeal, ZZ) := MonomialIdeal => (I, n) ->
(
    -- throw an exception is I is not a primary ideal
    assert isPrimary I;

    -- do some stuff...

    -- for now, assuming generated by pure powers
    -- getting the values of the powers
    -- and the variables appearing in I
    G = first entries mingens I;
    num = #G;
    -- an element of L is (variable, power of variable in generators of I)
    L = apply(num, i -> ((support G_i)_0, first degree G_i));
    -- TODO: finish finding generators of diff power
    Gpow = apply(num, i -> ((L_i)_0)^((L_i)_1 + n - 1));
    -- get a list of combinations of variables
    C = {};
    for i from 2 to num do 
        C = append(C, select(compositions (num, i), comp -> all(comp, c -> c <= 1)));

    << "List of compositions: " << C << endl;
    -- for each combination, assign powers properly (finish)
    for i from 0 to #C - 1 do
        (deg = n;
        for j from 0 to #(C_i) - 1 do
            (apply(#((C_i)_j), k -> (deg = deg + ((((C_i)_j)_k) * ((L_k)_1)) - 1;));
            Pows = select(compositions(i + 2, deg), comp -> all(comp, c -> c > 0));
            )
        )
    -- testing below
)


diffPowerMonomial = method()

diffPowerMonomial( MonomialIdeal, ZZ) := MonomialIdeal => (I, n) ->
(
    -- take a primary decomposition of I,
    -- take each primary component to nth differential power,
    -- intersect the ideals you get.

    intersect apply(primaryDecomposition I, J -> diffPowerPrimaryMonomial(J, n))
)
